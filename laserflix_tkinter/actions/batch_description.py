"""\nActions ‚Äî Batch Description\nGera√ß√£o de descri√ß√µes em lote\n"""\n\nimport threading\nfrom config import LOGGER\n\n\nclass BatchDescription:\n    def __init__(self, ai_description_gen, database_manager, progress_callbacks=None):\n        """\n        progress_callbacks: dict com {\n            'update': func(current, total, message),\n            'show': func(),\n            'hide': func(),\n            'status': func(message)\n        }\n        """\n        self.desc_gen = ai_description_gen\n        self.db = database_manager\n        self.callbacks = progress_callbacks or {}\n        self.analyzing = False\n        self.stop_flag = None\n\n    def set_stop_flag(self, stop_flag_obj):\n        """Define objeto com atributo stop_analysis."""\n        self.stop_flag = stop_flag_obj\n\n    def generate_descriptions_for_new(self):\n        """Retorna projetos sem descri√ß√£o."""\n        projects = [p for p, d in self.db.database.items()\n                    if not (d.get("ai_description") or "").strip()]\n        if not projects:\n            return False, "Todos os projetos j√° t√™m descri√ß√£o!"\n        return True, projects\n\n    def generate_descriptions_for_all(self):\n        """Retorna todos os projetos para gera√ß√£o."""\n        all_projects = list(self.db.database.keys())\n        if not all_projects:\n            return False, "Nenhum projeto encontrado!"\n        return True, all_projects\n\n    def generate_descriptions_for_filter(self, filtered_projects):\n        """Gera descri√ß√µes para projetos do filtro."""\n        if not filtered_projects:\n            return False, "Nenhum projeto no filtro atual!"\n        return True, filtered_projects\n\n    def run_description_generation(self, projects_list, description, root_widget=None):\n        """Executa gera√ß√£o de descri√ß√µes em thread separada."""\n        self.analyzing = True\n        if self.stop_flag:\n            self.stop_flag.stop_analysis = False\n        total = len(projects_list)\n\n        def generate_batch():\n            if self.callbacks.get('show') and root_widget:\n                root_widget.after(0, self.callbacks['show'])\n            completed = 0\n            for i, path in enumerate(projects_list, 1):\n                if self.stop_flag and getattr(self.stop_flag, 'stop_analysis', False):\n                    break\n                project_name = self.db.database[path].get("name", "Sem nome")[:30]\n                if self.callbacks.get('update') and root_widget:\n                    root_widget.after(0, lambda i=i, t=total, n=project_name:\n                                    self.callbacks['update'](i, t, f"üìù Gerando: {n}"))\n                self.desc_gen.generate_ai_description(path, self.db.database[path], self.db.database)\n                self.db.save_database()\n                completed = i\n            self.analyzing = False\n            final_msg = f"‚úì {completed} descri√ß√µes geradas ({description})"\n            if self.stop_flag and getattr(self.stop_flag, 'stop_analysis', False) and completed < total:\n                final_msg = f"‚èπ Parado: {completed}/{total} descri√ß√µes ({description})"\n            if self.callbacks.get('status') and root_widget:\n                root_widget.after(0, lambda: self.callbacks['status'](final_msg))\n            if self.callbacks.get('hide') and root_widget:\n                root_widget.after(0, self.callbacks['hide'])\n            if self.stop_flag:\n                self.stop_flag.stop_analysis = False\n\n        threading.Thread(target=generate_batch, daemon=True).start()\n        return True\n