"""\nActions â€” Batch Analysis\nAnÃ¡lise em lote de projetos\n"""\n\nimport threading\nfrom config import LOGGER, FAST_MODEL_THRESHOLD\n\n\nclass BatchAnalysis:\n    def __init__(self, ai_analyzer, database_manager, progress_callbacks=None):\n        """\n        progress_callbacks: dict com {\n            'update': func(current, total, message),\n            'show': func(),\n            'hide': func(),\n            'status': func(message)\n        }\n        """\n        self.ai_analyzer = ai_analyzer\n        self.db = database_manager\n        self.callbacks = progress_callbacks or {}\n        self.analyzing = False\n        self.stop_flag = None\n\n    def set_stop_flag(self, stop_flag_obj):\n        """Define objeto com atributo stop_analysis."""\n        self.stop_flag = stop_flag_obj\n\n    def analyze_only_new(self, root_widget=None):\n        """Analisa apenas projetos nÃ£o analisados."""\n        unanalyzed = [p for p, d in self.db.database.items() if not d.get("analyzed")]\n        if not unanalyzed:\n            return False, "Todos os projetos jÃ¡ foram analisados!"\n        return True, unanalyzed\n\n    def reanalyze_all(self):\n        """Retorna todos os projetos para reanÃ¡lise."""\n        all_projects = list(self.db.database.keys())\n        if not all_projects:\n            return False, "Nenhum projeto encontrado!"\n        return True, all_projects\n\n    def analyze_current_filter(self, filtered_projects):\n        """Analisa projetos do filtro atual."""\n        if not filtered_projects:\n            return False, "Nenhum projeto no filtro atual!"\n        return True, filtered_projects\n\n    def run_analysis(self, projects_list, description, root_widget=None):\n        """Executa anÃ¡lise em lote em thread separada."""\n        self.analyzing = True\n        if self.stop_flag:\n            self.stop_flag.stop_analysis = False\n        total = len(projects_list)\n        role = "text_fast" if total > FAST_MODEL_THRESHOLD else "text_quality"\n        model_used = self.ai_analyzer.text_gen.client.get_model_name(role)\n\n        def analyze_batch():\n            if self.callbacks.get('show') and root_widget:\n                root_widget.after(0, self.callbacks['show'])\n            completed = 0\n            for i, path in enumerate(projects_list, 1):\n                if self.stop_flag and getattr(self.stop_flag, 'stop_analysis', False):\n                    break\n                project_name = self.db.database[path].get("name", "Sem nome")[:30]\n                if self.callbacks.get('update') and root_widget:\n                    root_widget.after(0, lambda i=i, t=total, n=project_name:\n                                    self.callbacks['update'](i, t, f"ðŸ¤– [{model_used[:15]}] {n}"))\n                categories, tags = self.ai_analyzer.analyze_with_ai(path, batch_size=total)\n                self.db.database[path]["categories"] = categories\n                self.db.database[path]["tags"] = tags\n                self.db.database[path]["analyzed"] = True\n                self.db.database[path]["analyzed_model"] = model_used\n                self.db.save_database()\n                completed = i\n            self.analyzing = False\n            final_msg = f"âœ“ {completed} projetos analisados ({description}) [{model_used}]"\n            if self.stop_flag and getattr(self.stop_flag, 'stop_analysis', False) and completed < total:\n                final_msg = f"â¹ Parado: {completed}/{total} ({description})"\n            if self.callbacks.get('status') and root_widget:\n                root_widget.after(0, lambda: self.callbacks['status'](final_msg))\n            if self.callbacks.get('hide') and root_widget:\n                root_widget.after(0, self.callbacks['hide'])\n            if self.stop_flag:\n                self.stop_flag.stop_analysis = False\n\n        threading.Thread(target=analyze_batch, daemon=True).start()\n        return True\n